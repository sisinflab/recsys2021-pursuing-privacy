import random

Q = 121639451781281043402593


def encrypt(secret):
    share0 = random.randrange(Q)
    share1 = (secret - share0) % Q
    return share0, share1


def decrypt(share0, share1):
    return (share0 + share1) % Q


def encode(rational):
    upscaled = int(rational * 10**6)
    field_element = upscaled % Q
    return field_element


def decode(field_element):
    upscaled = field_element if field_element <= Q/2 else field_element - Q
    rational = upscaled / 10**6
    return rational


def generate_mul_triple():
    # Generated by the crypto provider
    a = random.randrange(Q)
    b = random.randrange(Q)
    c = (a * b) % Q
    return PrivateValue(a), PrivateValue(b), PrivateValue(c)
    # The shares of these numbers are distributed to the two parts


class PublicValue:
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        if type(other) is PrivateValue:
            return other + self
        elif type(other) is PublicValue:
            return PublicValue(self.value + other.value)

    def __sub__(self, other):
        if type(other) is PrivateValue:
            return other * PublicValue(-1) + self
        elif type(other) is PublicValue:
            return PublicValue(self.value - other.value)

    def __mul__(self, other):
        if type(other) is PrivateValue:
            return other * self
        elif type(other) is PublicValue:
            return PublicValue(self.value * other.value)


class PrivateValue:
    def __init__(self, value, share0=None, share1=None):
        if not value is None:
            share0, share1 = encrypt(value)
        self.share0 = share0
        self.share1 = share1

    def decrypt(self):
        return PublicValue(decrypt(self.share0, self.share1))

    def __add__(self, other):
        if type(other) is PublicValue:
            share0 = (self.share0 + other.value) % Q
            share1 = self.share1
            return PrivateValue(None, share0, share1)
        elif type(other) is PrivateValue:
            share0 = (self.share0 + other.share0) % Q
            share1 = (self.share1 + other.share1) % Q
            return PrivateValue(None, share0, share1)

    def __sub__(self, other):
        if type(other) is PublicValue:
            share0 = (self.share0 - other.value) % Q
            share1 = self.share1
            return PrivateValue(None, share0, share1)
        elif type(other) is PrivateValue:
            share0 = (self.share0 - other.share0) % Q
            share1 = (self.share1 - other.share1) % Q
            return PrivateValue(None, share0, share1)

    def __mul__(self, other):
        if type(other) is PublicValue:
            share0 = (self.share0 * other.value) % Q
            share1 = (self.share1 * other.value) % Q
            return PrivateValue(None, share0, share1)
        elif type(other) is PrivateValue:
            a, b, a_mul_b = generate_mul_triple()
            alpha = (self - a).decrypt()
            # i.e., each party subtracts a from self, then they jointly reconstruct this value
            beta = (other - b).decrypt()
            # i.e., each party subtracts a from other, then they jointly reconstruct this value
            return (alpha * beta) + (a * beta) + (b * alpha) + a_mul_b
            # i.e., (self * other - self * b - other * a + a * b) + (other * a - a * b) +
            # (self * b - a * b) + (a * b)


a = PrivateValue(encode(0.2))
b = PrivateValue(encode(0.5))
print(decode((a + b).decrypt().value))